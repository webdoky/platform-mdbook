{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Introduction", "Web/JavaScript/Guide/Control_flow_and_error_handling")}} Цей розділ описує базову граматику JavaScript, оголошення змінних, типи даних та літерали. Основи JavaScript запозичив більшість свого синтаксису в Java, C і C++, але також отримав вплив від Awk, Perl і Python. JavaScript є чутливим до регістру та використовує набір символів Unicode. Наприклад, слово Früh (котре перекладається з німецької як "рано") може використовуватися як ім'я змінної. Однак змінна früh – не та сама, що й Früh, адже JavaScript чутливий до регістру. У JavaScript інструкції розділяються крапкою з комою (;). Крапка з комою не потрібна після інструкції, якщо ця інструкція написана на окремому рядку. Проте якщо в рядку потрібна більш ніж одна інструкція, то такі інструкції повинні бути розділені крапками з комою. Проте найкращою практикою вважається завжди ставити після інструкції крапку з комою, навіть тоді, коли вона не вимагається суворо. Така практика зменшує шанс появи помилок у коді. Вихідний текст сценарію JavaScript сканується зліва направо і перетворюється на послідовність елементів введення, які є лексемами, контрольними символами, символами кінця рядка, коментарями та пробільними символами. (Пробіли, табуляції та символи нового рядка вважаються пробільними символами.) Коментарі Синтаксис коментарів – такий же, як у C++ і багатьох інших мовах: Блокові коментарі не можна вкладати одне в одного. Це нерідко трапляється, якщо випадково додати в коментар послідовність */, яка завершує коментар. У такому випадку необхідно розірвати патерн */. Наприклад, вставивши зворотну скісну риску: Коментарі поводяться як пробільні символи та відкидаються під час виконання сценаріїв. Оголошення JavaScript має три різновиди оголошень змінних. Змінні Змінні використовуються як символічні назви для значень у застосунку. Назви змінних, що звуться ідентифікаторами, відповідають певним правилам. Ідентифікатор JavaScript зазвичай починається з літери, підкреслення (_) або знаку долара ($). Наступні символи також можуть бути цифрами (0 – 9). Оскільки JavaScript розрізняє регістр, літери включають символи від A до Z (великі літери), а також від a до z (малі літери). У ідентифікаторах можна використовувати більшість літер Unicode, наприклад, å і ü. (Дивіться детальніше в довідці про лексичну граматику.) Також для представлення символів у ідентифікаторах можна використовувати послідовності екранування Unicode. Приклади дозволених назв: Number_hits, temp99, $credit, _name. Оголошення змінних Змінну можна оголосити двома шляхами: Змінні можна оголошувати для розпакування значень за допомогою синтаксису присвоєння з деструктуруванням. Наприклад, const { bar } = foo. Це створить змінну з назвою bar і присвоїть їй значення, що відповідає ключу з такою ж назвою з об'єкта foo. Змінні завжди повинні бути оголошені до свого використання. Колись JavaScript дозволяв присвоєння значень неоголошеним змінним, що породжувало неоголошені глобальні змінні. Це є помилкою в суворому режимі, і взагалі, цього слід уникати. Оголошення й ініціалізація У інструкції виду let x = 42 частина let x зветься оголошенням, а частина = 42 – ініціалізатором. Завдяки оголошенню далі в коді до змінної можна звертатися без викидання ReferenceError, а ініціалізатор присвоює їй значення. У оголошеннях var і let ініціалізатор є необов'язковим. Якщо змінна оголошена без ініціалізатора, то їй присвоюється значення undefined. По суті let x = 42 рівносильно щодо let x; x = 42. Оголошення const завжди потребують ініціалізатора, адже забороняють будь-якого роду присвоєння після оголошення, і неявна ініціалізація їх значенням undefined, ймовірно, є помилкою програміста. Область видимості змінних Змінна може належати до однієї з наступних областей видимості: На додачу, змінні, оголошені з let або const, можуть належати до ще однієї області видимості: Коли змінна оголошується поза будь-якою функцією, вона зветься *глобальною, тому що доступна для будь-якого іншого коду в поточному документі. Коли оголосити змінну в функції, вона зветься *локальною_, тому що доступна лише в межах цієї функції. Оголошення let і const також можуть бути обмежені інструкцією-блоком, у якій оголошені Проте змінні, створені з var, не обмежені блоком, але є локальними відносно функції (або глобальної області видимості), в якій знаходиться блок. Наприклад, наступний код виведе 5, тому що область видимості x – це глобальний контекст (або функційний контекст, якщо цей код є частиною функції). Область видимості x не обмежена блоком if безпосередньо навколо змінної. Підняття змінних Оголошені з var змінні піднімаються, тобто можна звертатися до змінної будь-де в її області видимості, навіть якщо виконання ще не дійшло до її оголошення. Оголошення змінної var можна розглядати як такі, що "піднімаються" до початку своєї функції або глобальної області видимості. Проте якщо звернутися до змінної до її оголошення, то її значення завжди буде undefined, оскільки піднімається лише оголошення, але не її ініціалізація. Приклади вище тлумачаться так само, як: У зв'язку з підняттям усі інструкції var у функції повинні ставитися настільки близько до верху функції, наскільки можливо. Така найкраща практика підвищує зрозумілість коду. Те, чи піднімаються let і const, є предметом суперечок. Звертання до таких змінних у блоці до їхнього оголошення завжди призводить до ReferenceError, тому що вони перебувають у "темпоральній мертвій зоні" від початку блоку до обробки оголошення. На відміну від оголошень var, котрі піднімають лише оголошення, але не своє значення, оголошення функцій піднімаються повністю – функцію можна безпечно викликати будь-де в її області видимості. Дивіться більше про це в записі глосарія про підняття. Глобальні змінні Глобальні змінні фактично є властивостями глобального об'єкта. На вебсторінках глобальним об'єктом є window, тож задавати та звертатися до глобальних змінних можна за допомогою запису window.variable. У всіх середовищах можна використовувати для звертання до глобальних змінних змінну globalThis (котра сама є глобальною змінною). Як наслідок, до змінних, оголошених в одному вікні чи фреймі, можна звертатися з іншого вікна чи фрейму, задавши ім'я window або frame. Наприклад, якщо в документі оголошена змінна phoneNumber, то до неї можна звертатися з iframe як до parent.phoneNumber. Сталі Доступні лише для читання іменовані сталі можна створювати за допомогою ключового слова const. Синтаксис ідентифікатора сталої – такий самий, як в будь-якого ідентифікатора змінної: повинен починатися з літери, підкреслення чи знаку долара ($), і може містити літери, цифри та підкреслення. Стала не може змінювати значення шляхом присвоєння чи бути оголошена повторно, поки сценарій працює. Вона повинна бути ініціалізована значенням. Правила областей видимості для сталих – такі самі, як правила для змінних let з блоковою областю видимості. Не можна оголосити сталу з таким же ім'ям, як у функції чи змінної в тій самій області видимості. Наприклад: Проте const запобігає лише повторному присвоєнню, але не запобігає видозмінам. Властивості об'єктів, присвоєних сталим, не захищені, тож наступна інструкція виконується без проблем. Крім цього, вміст масиву – не захищений, тож наступна інструкція виконується без проблем. Структури даних і типи Типи даних Останній стандарт ECMAScript визначає вісім типів даних: Попри те, що цих типів даних відносно небагато, вони дають змогу виконувати в застосунках корисні дії. Функції – іще один засадничий елемент мови. Хоч функції технічно є різновидом об'єктів, об'єкти можна уявляти як іменовані контейнери для значень, а функції – як процедури, які може виконувати сценарій. Перетворення типів даних JavaScript – мова з динамічною типізацією. Це означає, що не потрібно задавати тип даних змінної, коли вона оголошується. Також це означає, що під час виконання сценарію між типами даних за потреби відбуваються автоматичні перетворення. Тож, наприклад, можна визначити змінну так: А пізніше – їй можна присвоїти рядкове значення, наприклад: Оскільки JavaScript має динамічну типізацію, таке присвоєння не призводить до повідомлення про помилку. Числа та оператор '+' У виразах, що включають числові та рядкові значення з оператором +, JavaScript перетворює числові значення на рядки. Наприклад, погляньмо на наступні інструкції: У випадку всіх інших операторів, JavaScript не перетворює числові значення на рядки. Наприклад: Перетворення рядків на числа На випадок значень, які представляють числа, але зберігаються в пам'яті як рядки, є методи для перетворення. Функція parseInt повертає лише цілі числа, тож її корисність для десяткових дробів – обмежена. Інший варіант отримання числа з рядка – оператор + (унарний плюс): Літерали Літерали в JavaScript представляють значення. Це фіксовані значення – не змінні – які літерально (буквально) вказуються в сценарії. У цьому розділі описано наступні типи літералів: Літерали масивів Літерал масиву – це список з нуля чи більше виразів, кожний з яких представляє елемент масиву, оточений квадратними дужками ([]). При створенні масиву за допомогою літерала він ініціалізується вказаними значеннями як його елементами, а його length задається як кількість перелічених аргументів. Наступний приклад створює масив coffees з трьома елементами та length зі значенням трьох: Якщо масив створюється за допомогою літерала у сценарії найвищого рівня, то JavaScript тлумачить його щоразу, коли обчислює вираз, що вміщає літерал масиву. Крім цього, літерал, що вміщений у функції, створюється заново щоразу, коли вона викликається. Надлишкові коми в літералах масивів Якщо поставити в літералі масиву дві коми підряд, то масив залишить для невказаного елемента порожню комірку. Наступний приклад створює масив fish: Якщо вивести цей масив, то буде видно: Зверніть увагу на те, що другий елемент – "порожній", що не зовсім те саме, що фактичне значення undefined. При використанні методів з обходом масиву, наприклад, Array.prototype.map, порожні комірки пропускаються. Проте звертання до індексу fish[1] все ж поверне undefined. Якщо додати кому в кінці списку елементів, то вона ігнорується. У наступному прикладі length масиву – три. Немає жодного myList[3]. Всі інші коми в списку позначають новий елемент. Нижче, довжина length масиву дорівнює чотири, причому елементи myList[0] та myList[2] – відсутні. А в цьому прикладі, довжина length масиву дорівнює чотири, і елементи myList[1] та myList[3] – відсутні. Ігнорується лише остання кома. Розуміння логіки надлишкових ком у літералах масивів – важливий елемент розуміння JavaScript як мови. Проте при написанні власного коду слід явно оголошувати пропущені елементи як undefined, або щонайменше додавати коментар, щоб виділити відсутність. Це збільшує зрозумілість та полегшує підтримку коду. Булеві літерали Булів тип має два літеральні значення: true і false. Числові літерали Серед числових літералів JavaScript – літерали цілих чисел з різними основами числення, а також літерали чисел з рухомою комою в десятковій системі числення. Зверніть увагу на те, що специфікація вимагає, щоб числові літерали були беззнаковими. Попри це, фрагменти коду виду -123.4 – допустимі, оскільки тлумачаться як унарний оператор -, що застосовується до числового літерала 123.4. Цілочислові літерали Літерали цілих чисел і BigInt можуть записуватися в десятковій (основа 10), шістнадцятковій (основа 16), вісімковій (основа 8) і двійковій (основа 2) системах числення. Трохи прикладів цілочислових літералів: Більше про це дивіться в Числових літералах у довідці Лексичної граматики. Дробові літерали Дробовий літерал може мати наступні частини: Частина експоненти – це літера e або E, після якої стоїть ціле число, яке може бути зі знаком (з + або - перед ним). Дробовий літерал повинен вміщати принаймні одну цифру, а також десятковий розділювач або e (чи E). Якщо стисліше, то синтаксис такий: Наприклад: Літерали об'єктів Літерал об'єкта – це список з нуля чи більше пар імен властивостей та пов'язаних з ними значень в об'єкті, оточений фігурними дужками ({}). Код далі є прикладом літерала об'єкта. Перший елемент об'єкта car визначає властивість, myCar, і присвоює їй новий рядок, "Saturn"; наступному елементу, властивості getCar, негайно присвоюється результат заклику функції (carTypes("Honda")); третій елемент, властивість special, використовує наявну змінну (sales). Крім цього, можна використовувати числовий або рядковий літерал як ім'я властивості, або вкласти один об'єкт в інший. Наступний приклад використовує ці можливості. Ім'я властивості об'єкта може бути будь-яким рядком, включно з порожнім рядком. Якщо ім'я властивості не є дійсним ідентифікатором JavaScript або числом, то його потрібно оточити лапками. За іменами властивостей, що не є дійсними ідентифікаторами, не можна звертатися як до властивостей з крапкою (.). Натомість, до них слід звертатися за допомогою квадратних дужок ([]). Покращені літерали об'єктів Літерали об'єктів підтримують низку скорочених записів, серед яких задання прототипу при створенні, скорочений запис для присвоєнь foo: foo, визначення методів, виклики super та обчислення імен властивостей за допомогою виразів. Все разом це також зближує літерали об'єктів і оголошення класів, а також дає об'єктноорієнтованому проєктуванню можливість скористатися деякими зручностями. Літерали RegExp Літерал регулярного виразу (детально описаний пізніше) – це патерн, оточений скісними рисками. Наступний приклад містить літерал регулярного виразу. Рядкові літерали Рядковий літерал – це нуль або більше символів, оточених подвійними (") або одинарними (') лапками. Рядок повинен бути обмежений лапками одного типу (тобто або подвійними лапками, або одинарними). Наступний приклад містить рядкові літерали: Рядкові літерали слід використовувати, якщо немає конкретної потреби використовувати об'єкт String. Більше про об'єкти String читайте на сторінці String. Будь-який з методів об'єкта String можна викликати на рядковому літеральному значенні. JavaScript автоматично перетворює рядковий літерал на тимчасовий об'єкт String, викликає метод, а тоді викидає тимчасовий об'єкт String. Також можна використовувати на рядковому літералі властивість length: Також доступні шаблонні літерали. Шаблонні літерали оточуються символами слабкого наголосу (`) (гравісами), а не подвійними чи одинарними лапками. Шаблонні літерали надають синтаксичний цукор для створення рядків. (Це схоже на можливості рядкової інтерполяції в Perl, Python і не тільки.) Теговані шаблони – це стислий синтаксис для задання шаблонного літерала вкупі з викликом функції "тегу" для його розбору. Тегований шаблон – це лишень стисліший та семантичний спосіб для заклику функції, що обробляє рядок, і задає відповідні значення. Ім'я шаблонної тегової функції ставиться перед шаблонним літералом – як у наступному прикладі, де шаблонна тегова функція зветься print. Функція print інтерполює аргументи та серіалізує всі об'єкти чи масиви, що можуть зустрітися, уникаючи неприємного [object Object]. Оскільки теговані шаблонні літерали – це лишень цукор викликів функцій, код вище можна переписати у вигляді рівносильного виклику функції: Це може нагадувати про інтерполяцію в стилі console.log: Як видно, теговані шаблони читаються природніше за традиційну функцію-"форматувальника", для якої змінні та сам шаблон повинні бути оголошені окремо. Використання в рядках спеціальних символів Крім звичайних символів, у рядки можна додавати спеціальні символи, як показано в наступному прикладі. Наступна таблиця перелічує спеціальні символи, які можна використовувати в рядках JavaScript. Екранування символів Для символів, не згаданих у таблиці вище, зворотний скіс перед ними ігнорується, але таке його використання є нерекомендованим, його слід уникати. Символи лапок можна додавати в рядок, ставлячи перед ними зворотний скіс. Це зветься екрануванням символу лапки. Наприклад: Результатом буде: Щоб додати в рядок буквальний зворотний скіс, необхідно екранувати його. Наприклад, щоб присвоїти рядкове значення c:\temp, слід використати наступне: Також можна екранувати розриви рядків, ставлячи перед ними зворотні скоси. І зворотні скоси, і розриви рядків тоді вилучаються зі значення рядка. Більше інформації Цей розділ зосереджений на базовому синтаксисі оголошень і типів. Щоб дізнатися більше про конструкції мови JavaScript, також варто переглянути наступні розділи цього посібника: У наступному розділі поглянемо на конструкції керування плином виконання й обробку помилок. {{PreviousNext("Web/JavaScript/Guide/Introduction", "Web/JavaScript/Guide/Control_flow_and_error_handling")}}