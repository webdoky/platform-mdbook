{{jsSidebar("More")}} Шаблонні літерали — це літерали, які виділяються символами тупого наголосу (`), і дають можливість використовувати багаторядковий текст, інтерполяцію рядків із вбудованими виразами, і також особливими конструкціями, які називаються тегованими шаблонами. Шаблонні літерали інколи неформально називають шаблонними рядками, оскільки одним з основних способів їхнього застосування є інтерполяція рядків (створення рядків шляхом підставляння полів для заповнення). Хоча теговані шаблонні літерали можуть і не виводити рядок взагалі; їх можна застосувати із довільною теговою функцією для виконання будь-яких операцій із різними частинами шаблонного літерала. Синтаксис Параметри Опис Шаблонні літерали виділяються символами тупого наголосу (`) замість одинарних чи подвійних лапок. Поряд зі звичайними рядками, шаблонні літерали можуть містити інші частини — так звані поля для заповнення, які являються вбудованими виразами, виділеними знаком долара і фігурними дужками (${вираз}). Рядки й поля для заповнення передаються до функції: або усталеної, або переданої в коді. Усталена функція (що спрацьовує, коли явно не вказано іншої) виконує лише інтерполяцію рядків для підставляння значень у поля для заповнення, і потім з'єднує всі частини у цілий рядок. Аби передати власну функцію, достатньо вказати її ім'я перед шаблонним літерам. Вираз, отриманий в результаті, називається тегований шаблон. В цьому випадку шаблонний літерал буде передано до вказаної тегової функції, де можна буде виконати будь-які операції з різними частинами шаблонного літерала. Для екранування символу тупого наголосу всередині шаблонного літерала достатньо поставити перед ним зворотний скіс (\). Також для запобігання інтерполяції можна екранувати знак долара. Багаторядковий текст Будь-який символ нового рядка, присутній у початковому коді, входить до складу шаблонного літерала. Під час використання звичайних рядків слід використовувати наступний синтаксис, аби отримати багаторядний текст: З шаблонними літералами аналогічного результату можна досягнути так: Інтерполяція рядків За відсутності шаблонних літералів, коли є потреба скомбінувати вивід виразу із рядками, знадобилося б зчепити їх докупи за допомогою оператора додавання +: Це може бути складним для прочитання, особливо якщо там є декілька виразів. Можна уникнути вживання оператора конкатенації — а також покращити зрозумілість коду — використавши шаблонні літерали шляхом додавання полів для заповнення у формі ${вираз}, для виконання заміни вбудованих виразів: Зверніть увагу, що між двома синтаксисами присутня певна відмінність. Шаблонні літерали напряму зводять свої вирази до рядків, натомість додавання спершу зводить свої операнди до примітивів. Для отримання подробиць дивіться довідкову сторінку оператора &#43;. Вкладення шаблонів В деяких випадках вкладання шаблону — це найпростіший (і, ймовірно, зручніший для читання) спосіб отримання рядків, які можна налаштовувати. Всередині шаблону, виділеного тупими наголосами, можна використати вкладений шаблон, просто вживши його всередині поля для заповнення ${вираз} в шаблоні. Наприклад, якби потрібно було повернути певне значення залежно від конкретної умови, за відсутності шаблонних літералів — можна було б зробити щось схоже на наступний приклад: Із шаблонним літералом, але без вкладання, можна було б зробити таким чином: З вкладеними шаблонними літералами можна робити так: Теговані шаблони Більш розширена форма шаблонних літералів — це теговані шаблони. Теги дають змогу розбирати шаблонні літерали за допомогою функції. Перший аргумент тегової функції містить масив рядкових значень. Решта аргументів належать до виразів. Тегова функція далі може виконати які завгодно операції на цих аргументах і повернути оброблений рядок. (Вона також може повертати щось абсолютно інше, як описано в одному з прикладів нижче.) Назва функції, яку вжито як тег, може бути якою завгодно. Тег не зобов'язаний бути простим ідентифікатором. Можна використати будь-який вираз з пріоритетом понад 16, в тому числі звертання до властивості, виклик функції, вираз new, або навіть інший тегований шаблонний літерал. Хоч це технічно дозволено синтаксисом, нетеговані шаблонні літерали є рядками та викинуть TypeError, якщо їх додати в ланцюжок. Єдиним винятком є необов'язкове зв'язування, котре викине синтаксичну помилку. Зверніть увагу, що ці два вирази усе ж є розбірливими. Це означає, що вони не будуть піддані автоматичному доданню крапки з комою, котре додає крапку з комою для виправлення коду, котрий без цього є нерозбірливим. Тегові функції навіть не зобов'язані повертати саме рядок! Перший аргумент, отриманий теговою функцією, є масивом рядків. Для будь-якого шаблонного літерала довжина такого масиву рівна кількості підставлень (входжень ${…}) плюс один, а отже – цей масив ніколи не є порожнім. Для кожного конкретного виразу тегованого шаблонного літерала тегова функція завжди викликатиметься з тим самим літералом масиву, незалежно від того, скільки разів обчислюється літерал. Це дає тегові змогу кешувати результат на основі ідентичності його першого аргументу. Щоб іще краще пересвідчитися щодо стабільності значення масиву, і перший аргумент, і його властивість raw – заморожуються, тож їх не можна змінити в жоден спосіб. Необроблені рядки Особлива властивість raw, наявна в першому аргументі тегової функції, дає змогу доступитися до необроблених рядків в тому вигляді, в якому їх було введено, без обробки екранованих послідовностей. На додаток, для створення необроблених рядків існує метод String.raw(), який працює точнісінько так само, як усталена тегова функція і конкатенація рядків. String.raw працює як тег "ідентичності", якщо літерал не містить жодних послідовностей екранування. Якщо потрібен справжній тег ідентичності, котрий завжди працює так, ніби літерал є нетегованим, можна створити власну функцію, котра передає "приготований" (тобто такий, в якому послідовності екранування були оброблені) літерал масиву в String.raw, удаючи, ніби це необроблені рядки. Це корисно для багатьох інструментів, що надають особливу обробку літералам, тегованим певним конкретним ім'ям. Теговані шаблони і екрановані послідовності У звичайних шаблонних літералах дозволені усі екрановані послідовності рядкових літералів. Будь-які інші погано сформовані екрановані послідовності є синтаксичною помилкою. Серед них: Проте це є проблемним для тегованих шаблонів, котрі, на додачу до "приготованого" літерала, також мають доступ до необроблених лібералів (у котрих екрановані послідовності збережені як є). Теговані шаблони повинні дозволяти вбудовування мов (наприклад, предметноорієнтованих мов чи LaTeX), у котрих поширені інакші екрановані послідовності. Таким чином, синтаксичне обмеження щодо добре сформованих екранованих послідовностей з тегованих шаблонів було зняте. Все ж, недійсні екрановані послідовності все одно необхідно показати в "приготованому" виразі. Їх буде показано як невизначені елементи в масиві "cooked": Слід зауважити, що обмеження екранованих послідовностей було прибрано лише з тегованих шаблонів, проте в нетегованих літералах вони залишилися: {{Specifications}} Сумісність із браузерами {{Compat}}